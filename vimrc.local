"  ____ ____ ____ ____ ____ ____ ____ ____
" ||s |||e |||t |||t |||i |||n |||g |||s ||
" ||__|||__|||__|||__|||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|

let g:loaded_ctrlp = 1 " Don't load

set wildmenu " Enables a menu at the bottom of the vim window.
set wildmode=longest:full,full
" set scrolloff=999 " have cursor stay in the middle while scrolling
set undodir=$HOME/.undodir
set undofile
set clipboard=unnamed " copy paste to clipboard
set cursorline " highlight cursorline
set hlsearch " highlight search results
set matchtime=0 " Speed up escape after (){} chars
set ignorecase " case insensitive pattern matching
set ttimeout " Fast timeout
set smartcase " overrides ignorecase if pattern contains upcase
set wildignore+=tmp/** " Ignore stuff that can't be opened
set spelllang=en_us " Set region to US English
" Window size
set winwidth=84
set winheight=10
set winminheight=10
set winheight=999
set gdefault " Replace all matches on a line instead of just the first
set nowrap
set nofoldenable
set noshowmode
set complete=.,b,u,w,t,] " Pull from keywords in the current file and from the current tags file
set complete+=k~/.vim/dictionaries/array_methods.txt
set complete+=k~/.vim/dictionaries/float_methods.txt
set complete+=k~/.vim/dictionaries/hash_methods.txt
set complete+=k~/.vim/dictionaries/integer_methods.txt
set complete+=k~/.vim/dictionaries/string_methods.txt
set complete+=k~/.vim/dictionaries/rails_controller_completions.txt
set complete+=k~/.vim/dictionaries/rails_mailer_completions.txt
set complete+=k~/.vim/dictionaries/rails_migration_completions.txt
set complete+=k~/.vim/dictionaries/rails_model_completions.txt
set complete+=k~/.vim/dictionaries/rails_spec_completions.txt
set complete+=k~/.vim/dictionaries/ruby_template_completions.txt
set complete+=k~/.vim/dictionaries/capybara_matchers.txt
set complete+=k~/.vim/dictionaries/webdriver_io.txt
set completeopt=menu,preview " Shows menu and any addition tips
set relativenumber " Get the best of both worlds with set number and relativenumber
set number
autocmd InsertEnter * :set number norelativenumber
autocmd InsertLeave * :set relativenumber

set stl+=%{ConflictedVersion()} " Vim-Conflicted
let g:marked_app = 'Markoff' " Use thoughtbot's Markoff for markdown previews

autocmd! User GoyoEnter Limelight " Integrate limelight and goyo
autocmd! User GoyoLeave Limelight!

let g:rspec_command = "Dispatch rspec {spec}" " Vim Dispatch
let test#strategy = "dispatch"
let test#ruby#rspec#executable = 'SPEC_ALL=true bundle exec rspec'

let g:loaded_netrwPlugin = 1 " Dirvish
command! -nargs=? -complete=dir Vexplore leftabove vsplit | silent Dirvish <args>
command! -nargs=? -complete=dir Sexplore belowright split | silent Dirvish <args>
nnoremap gx :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<CR>
autocmd FileType dirvish call fugitive#detect(@%)

let g:colorizer_auto_filetype='sass,scss,css,html,slim,haml' " Colorizer
let g:jsx_ext_required = 0 " Allow JSX in normal JS files

filetype plugin on " Omnicompletion
set omnifunc=syntaxcomplete#Complete
inoremap <c-c> <c-x><c-o>

augroup rainbow " Rainbow Parens
  autocmd BufRead,BufNewFile * RainbowParentheses
augroup END

" Colorscheme and lightline config
let g:lightline = {
      \ 'colorscheme': 'seoul256',
      \ 'active': {
      \   'left': [
      \             ['mode', 'paste'],
      \             ['fugitive', 'readonly', 'myfilename', 'modified']
      \           ]
      \ },
      \ 'component': {
      \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}',
      \ },
      \ 'component_function': {
      \   'myfilename': 'LightLineFilename',
      \ },
      \ 'component_visible_condition': {
      \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
      \ }
      \ }

function! LightLineFilename()
  let git_root = fnamemodify(fugitive#extract_git_dir(expand("%:p")), ":h")

  if expand("%:t") == ""
    return "[No Name]"
  elseif git_root != "" && git_root != "."
    return substitute(expand("%:p"), git_root . "/", "", "")
  else
    return expand("%:p")
  endif
endfunction

let g:fzf_colors =
  \ { 'hl': ['fg', 'Exception'] }

" Syntastic
nnoremap <leader>o :Errors<CR>
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_check_on_open = 1
let g:syntastic_aggregate_errors = 1
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'
let g:syntastic_loc_list_height = 3

let g:syntastic_haml_checkers = ['haml_lint', 'haml']
let g:syntastic_html_checkers = ['jshint']
let g:syntastic_scss_checkers = ['scss_lint']
let g:syntastic_sass_checkers = ['sass-lint', 'sass_lint']
let g:syntastic_css_checkers = ['csslint']
let g:syntastic_ruby_checkers = ['mri', 'rubocop']
let g:syntastic_slim_checkers = ['slim_lint']
let g:syntastic_elixir_checkers = ['elixir']
let g:syntastic_javascript_checkers = ['eslint', 'jshint']
set autoread

"  ____ ____ ____ ____
" ||m |||a |||p |||s ||
" ||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|

" Open vimrc in new tab
nnoremap <Leader>vi :tabe ~/.vimrc.local<CR>
nnoremap <Leader>vb :tabe ~/.vimrc.bundles.local<CR>

" Source (reload) your vimrc. Type space, r, e in sequence to trigger
nnoremap <leader>re :source $MYVIMRC<CR>
nnoremap <leader>vr :sp $MYVIMRC<CR>

" Pre-populate a split command with the current directory
nnoremap <Leader>v :new <C-r>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <Leader>vn :vnew <C-r>=escape(expand("%:p:h"), ' ') . '/'<CR>

" Copy the entire buffer into the system register (from @R00k)
nnoremap <Leader>co mmggVG"*y`m

" Edit the db/schema.rb Rails file in a split
nnoremap <Leader>sc :split db/schema.rb<CR>

" Indent the whole file
nnoremap <Leader>i mmgg=G`m

" Set paste so paste works properly
nnoremap <Leader>p "*p

" Run vimscript functions
nnoremap <Leader>x :exec getline(".")<CR>

" Toggle spell checking on and off
nnoremap <silent> <leader>, :set spell!<CR>

" Require pry (from @christoomey)
nnoremap <leader>b orequire 'pry'; binding.pry<esc>^

" Convert Ruby 1.8 to 1.9 Hash Syntax
nnoremap <Leader>h :%s/:\([^ ]*\)\(\s*\)=>/\1:/g<CR>

" Toggle relative line number for yanking, i.e. :6y
nnoremap <leader>ln :set relativenumber!<CR>

" Make it easier to run ruby files inside vim
nnoremap <Leader>ru :!ruby -w %<CR>

" Open .html pages from vim in browser
nnoremap <leader>ht :!open '%'<CR>

" browse old files
nnoremap <leader>old :browse old<CR>

" Sed it up
nnoremap <leader>n :%s/\(<c-r>=expand("<cword>")<CR>\)/

" Comment/un-comment like Sublime (from @geoffharcourt)
nnoremap <C-\> :TComment<CR>
vnoremap <C-\> :TComment<CR>

" Use C-Space to Esc out of any mode (from @christoomey)
nnoremap <C-Space> <Esc>:noh<CR>
vnoremap <C-Space> <Esc>gV
onoremap <C-Space> <Esc>
cnoremap <C-Space> <C-c>
inoremap <C-Space> <Esc>`^
" oTerminal sees <C-@> as <C-space> WTF, but ok
nnoremap <C-@> <Esc>:noh<CR>
vnoremap <C-@> <Esc>gV
onoremap <C-@> <Esc>
cnoremap <C-@> <C-c>
inoremap <C-@> <Esc>`^

" Move up and down by visible lines if current line is wrapped
nnoremap j gj
nnoremap k gk

" Emacs-like beginning and end of line.
nnoremap <C-e> $
nnoremap <C-a> ^
imap <c-e> <c-o>$
imap <c-a> <c-o>^

" Search with fzf
nnoremap <C-p> :Files<CR>
nnoremap <C-o> :BLines<CR>
nnoremap <C-b> :Buffers<CR>
nnoremap <C-i> :Tags<CR>
nnoremap <C-t> :BTags<CR>

" View commits in fzf
nnoremap <Leader>c :Commits<CR>

" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" Advanced customization using autoload functions
inoremap <expr> <c-x><c-k> fzf#vim#complete#word({'left': '15%'})

" SideSearch current word and return to original window
nnoremap <Leader>ss :SideSearch <C-r><C-w><CR> | wincmd p

" Mappings to move lines. Symbols represent 'alt' because macs are insane
" 'j' = '∆' and 'k' = '˚'
" http://stackoverflow.com/questions/7501092/can-i-map-alt-key-in-vim
nnoremap ˚ :m .-2<CR>==
nnoremap ∆ :m .+1<CR>==
inoremap ˚ <Esc>:m .-2<CR>==gi
inoremap ∆ <Esc>:m .+1<CR>==gi
vnoremap ˚ :m '>-2<CR>gv=gv
vnoremap ∆ :m '<+1<CR>gv=gv

" Make yank behave like yank should
vnoremap <expr>y "my\"" . v:register . "y`y"

" map visual-block to v
nnoremap v <c-v>e

" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

" zoom a vim pane, <C-w>= to re-balance
nnoremap <leader>- :wincmd _<CR>:wincmd \|<CR>
nnoremap <leader>= :wincmd =<CR>

" map <ctrl>c to quit
nnoremap <c-c> :q<CR>

" Make n N nicer
function! s:nice_next(cmd)
  let view = winsaveview()
  execute "normal! " . a:cmd
  if view.topline != winsaveview().topline
    normal! zz
  endif
endfunction

nnoremap <silent> n :call <SID>nice_next('n')<CR>
nnoremap <silent> N :call <SID>nice_next('N')<CR>

" Make esc more user friendly
inoremap jk <esc>
inoremap ii <esc>

" comfortable-motion
let g:comfortable_motion_no_default_key_mappings = 1
nnoremap <silent> <C-d> :call comfortable_motion#flick(100)<CR>
nnoremap <silent> <C-u> :call comfortable_motion#flick(-100)<CR>

" make tab completion travel in a reasonable direction (from @geoffharcourt)
inoremap <S-Tab> <C-P>

" function! s:check_back_space()
"   let col = col('.') - 1
"   return !col "|| getline('.')[col - 1] !~ '\k'
" endfunction
"
" function! InsertTabWrapper()
"   if s:check_back_space()
"     return "\<Tab>"
"   else
"     return "\<C-n>"
"   endif
" endfunction
let g:SuperTabDefaultCompletionType = "<c-n>"

" vim-sneak
let g:sneak#s_next = 1
let g:sneak#label = 1

" Get dot command repeatability in visual mode // from @geoffharcourt
xnoremap . :normal.<CR>

" Set vimwiki path
let g:vimwiki_list = [{'path': '~/dotfiles-local/vimwiki/'}]

"  ____ ____ ____ ____
" ||t |||m |||u |||x ||
" ||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|

" To use c-h in neovim on OS X
" (https://github.com/neovim/neovim/issues/2048#issuecomment-78045837):
" infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti
" tic $TERM.ti
nnoremap <silent> <c-h> :TmuxNavigateLeft<CR>
nnoremap <silent> <c-j> :TmuxNavigateDown<CR>
nnoremap <silent> <c-k> :TmuxNavigateUp<CR>
nnoremap <silent> <c-l> :TmuxNavigateRight<CR>
" nnoremap <silent> <c-\> :TmuxNavigatePrevious<CR>

" Vim-tmux-navigator mappings
let g:tmux_navigator_no_mappings = 1

" Vim-tmux-runner
nnoremap <leader>fr :VtrFocusRunner<CR>
nnoremap <leader>sr :VtrSendLinesToRunner<CR>
nnoremap <leader>ap :VtrAttachToPane<CR>
nnoremap <leader>se :VtrSendCommand<CR>
nnoremap <leader>sf :VtrSendFile<CR>
nnoremap <leader>osr :VtrOpenRunner { 'orientation': 'h', 'percentage': 50 }<CR>

" Complete from open tmux panes (from @junegunn)
inoremap <expr> <C-x><C-i> fzf#complete('tmuxwords.rb --all-but-current --scroll 499 --min 5')
inoremap <expr> <C-x><C-k> fzf#complete('cat /usr/share/dict/words')

" Save on switch
let g:tmux_navigator_save_on_switch = 1

" Have tmux-runner open pry session
nnoremap <leader>pry :VtrOpenRunner {'orientation': 'h', 'percentage': 50, 'cmd': 'pry'}<CR>

" Save
nnoremap <C-z> :w<CR>

"  ____ ____ ____ ____ ____ ____
" ||n |||e |||o |||v |||i |||m ||
" ||__|||__|||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|/__\|/__\|

if has("nvim")

  " solarized
  " colorscheme solarized8_dark
  " colorscheme solarized8_dark_high
  " colorscheme solarized8_light

  " seoul256 (dark):
  colo seoul256
  "   Range:   233 (darkest) ~ 239 (lightest)
  "   Default: 237
  let g:seoul256_background = 235

  " seoul256 (light):
  " colo seoul256-light
  "   Range:   252 (darkest) ~ 256 (lightest)
  "   Default: 253
  " let g:seoul256_light_background = 256

  " Switch
  set background=dark
  " set background=light

  " nvim gui colors
  set termguicolors

  " the new cursor in 0.2.0 is awesome but might not be default for long so
  " leaving this enabled even if it disappears
  let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

  " Neovim terminal mappings for easy navigation
  au BufEnter * if &buftype == 'terminal' | :startinsert | endif
  tnoremap <C-h> <C-\><C-n><C-w>h
  tnoremap <C-j> <C-\><C-n><C-w>j
  tnoremap <C-k> <C-\><C-n><C-w>k
  tnoremap <C-l> <C-\><C-n><C-w>l
  tnoremap <C-d> <C-\><C-n>:bd!<CR>

  " NeoVim term colors
  let g:terminal_color_0  = '#616161' " black
  let g:terminal_color_1  = '#df9b99' " red
  let g:terminal_color_2  = '#719772' " green
  let g:terminal_color_3  = '#e0bc72' " yellow
  let g:terminal_color_4  = '#96bcdc' " blue
  let g:terminal_color_5  = '#e0bebc' " magenta
  let g:terminal_color_6  = '#98bcbd' " cyan
  let g:terminal_color_7  = '#d9d9d9' " white
  let g:terminal_color_8  = '#757575' " brblack
  let g:terminal_color_9  = '#e17899' " brred
  let g:terminal_color_10 = '#baddfc' " brgreen
  let g:terminal_color_11 = '#ffde99' " bryellow
  let g:terminal_color_12 = '#baddfc' " brblue
  let g:terminal_color_13 = '#ffbfbd' " brmagenta
  let g:terminal_color_14 = '#97dddf' " brcyan
  let g:terminal_color_15 = '#e9e9e9' " brwhite

  " Neomake
  " Disable inherited syntastic
  let g:syntastic_mode_map = {
    \ "mode": "passive",
    \ "active_filetypes": [],
    \ "passive_filetypes": [] }

  nnoremap <leader>o :lopen<CR>
  nnoremap <leader>oo :lclose<CR>

  let g:neomake_serialize = 1
  let g:neomake_serialize_abort_on_error = 1

" Run NeoMake on read and write operations
  autocmd! BufReadPost,BufWritePost * Neomake

  let g:neomake_javascript_enabled_makers = ['eslint', 'jshint', 'coffeelint']
  let g:neomake_scss_enabled_makers = ['scsslint']
  let g:neomake_css_enabled_makers = ['csslint']
  let g:neomake_markdown_enabled_makers = ['mdl']
  let g:neomake_ruby_enabled_makers = ['mri', 'rubocop', 'reek']
  let g:neomake_html_enabled_makers = ['htmlhint', 'tidy']
  let g:neomake_haml_enabled_makers = ['hamllint']
  let g:neomake_slim_enabled_makers = ['slimlint']
  let g:neomake_elixir_enabled_makers = ['elixir']

  " Use deoplete
  let g:deoplete#enable_at_startup = 1
  let g:deoplete#auto_complete_start_length = 1

  " TMUX complete
  let g:tmuxcomplete#trigger = ''

  " Open terminal in neovim
  nnoremap <leader>r :sp<CR>:terminal<CR>
  nnoremap <leader>rv :vsp<CR>:terminal<CR>

  " Open gitsh in terminal split
  nnoremap <leader>g :sp<CR>:terminal<CR>gsh<CR>

  nnoremap <leader>do :sp<CR>:terminal<CR>dotfiles<CR>gsh<CR>

  " Test with neovim
  let test#strategy = "neovim"

  set inccommand=split
endif
