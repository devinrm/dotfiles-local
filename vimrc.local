"  ____ ____ ____ ____ ____ ____ ____ ____
" ||s |||e |||t |||t |||i |||n |||g |||s ||
" ||__|||__|||__|||__|||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|/__\|/__\|/__\|/__\|

let g:loaded_ctrlp = 1 " Don't load
let s:darwin = has('mac')

set autoread
set background=dark
" set background=light
set clipboard=unnamed " copy paste to clipboard
set cursorline " highlight cursorline
set gdefault " Replace all matches on a line instead of just the first
set hlsearch " highlight search results
set ignorecase " case insensitive pattern matching
if has("nvim")
  set inccommand=split " this is necessary for using this %s with a quickfix window in nvim
endif
set matchtime=0 " Speed up escape after (){} chars
set mouse=a " Turn mouse on for pair programming
set nofoldenable
set noshowmode
set nowrap
set number
set relativenumber " Get the best of both worlds with set number and relativenumber
autocmd InsertEnter * :set number norelativenumber
autocmd InsertLeave * :set relativenumber
set scrolloff=5 " show 5 lines above and below cursor
set smartcase " overrides ignorecase if pattern contains upcase
set spelllang=en_us " Set region to US English
set ttimeout " Fast timeout
set undodir=$HOME/.undodir
set undofile
set wildignore+=tmp/** " Ignore stuff that can't be opened
set wildmenu " Enables a menu at the bottom of the vim window.
set wildmode=longest:full,full
set winwidth=84 " Window size
set winheight=10
set winminheight=10
set winheight=999

"  ____ ____ ____ ____ ____ ____ ____
" ||p |||l |||u |||g |||i |||n |||s ||
" ||__|||__|||__|||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|/__\|/__\|/__\|

" === ALE ===
" Disable inherited syntastic
let g:syntastic_mode_map = {
  \ "mode": "passive",
  \ "active_filetypes": [],
  \ "passive_filetypes": [] }

let g:ale_linters = {
       \ 'javascript': ['eslint']
       \ }
let g:ale_set_quickfix = 0
let g:ale_statusline_format = ['⨉ %d', '⚠ %d', '⬥ ok']
let g:ale_sign_error = '⚠ '
let g:ale_sign_warning = '⨉'
let g:ale_echo_msg_format = '[%linter%] %s'
highlight clear ALEErrorSign
highlight clear ALEWarningSign
set updatetime=1000
autocmd BufEnter * set conceallevel=0
autocmd CursorHold * call ale#Lint()
autocmd CursorHoldI * call ale#Lint()
autocmd InsertLeave * call ale#Lint()
autocmd TextChanged * call ale#Lint()
let g:ale_lint_on_text_changed = 0

" === colorizer ===
let g:colorizer_auto_filetype='sass,scss,css,html,slim,haml'

" === comfortable-motion.vim ===
let g:comfortable_motion_no_default_key_mappings = 1
nnoremap <silent> <C-d> :call comfortable_motion#flick(100)<CR>
nnoremap <silent> <C-u> :call comfortable_motion#flick(-100)<CR>

" === vim-conflicted ===
set stl+=%{ConflictedVersion()}

" === deoplete ===
let g:deoplete#enable_at_startup = 1
let g:deoplete#auto_complete_start_length = 1
" let g:deoplete#disable_auto_complete = 1 " only show comp menu on <tab>
let g:deoplete#max_list = 15

" === dirvish ===
let g:loaded_netrwPlugin = 1
command! -nargs=? -complete=dir Vexplore leftabove vsplit | silent Dirvish <args>
command! -nargs=? -complete=dir Sexplore belowright split | silent Dirvish <args>
nnoremap gx :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<CR>
autocmd FileType dirvish call fugitive#detect(@%)

" === dispatch.vim ===
let g:rspec_command = "Dispatch rspec {spec}"

" === fzf.vim ===
nnoremap <C-p> :Files<CR>
nnoremap <C-b> :Buffers<CR>
nnoremap <C-i> :Tags<CR>
nnoremap <C-t> :BTags<CR>
nnoremap <Leader>f :BLines<CR>
nnoremap <Leader>c :Commits<CR>
nnoremap <Leader>old :History<CR>
" grep the word under the cursor, select it, and then drop it into a quickfix
" window
nnoremap \\ :Ag <C-r><C-w><CR><C-a><CR>

let g:fzf_colors =
  \ { 'hl': ['fg', 'Exception'] }
" Mapping selecting mappings
nmap <Leader><tab> <plug>(fzf-maps-n)
xmap <Leader><tab> <plug>(fzf-maps-x)
omap <Leader><tab> <plug>(fzf-maps-o)
" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
" Advanced customization using autoload functions
inoremap <expr> <c-x><c-k> fzf#vim#complete#word({'left': '15%'})

" Narrow ag results within vim; CTRL-A to select all matches and list them in
" quickfix window
function! s:ag_to_qf(line)
  let parts = split(a:line, ':')
  return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
        \ 'text': join(parts[3:], ':')}
endfunction

function! s:ag_handler(lines)
  if len(a:lines) < 2 | return | endif

  let cmd = get({'ctrl-x': 'split',
               \ 'ctrl-v': 'vertical split',
               \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
  let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

  let first = list[0]
  execute cmd escape(first.filename, ' %#\')
  execute first.lnum
  execute 'normal!' first.col.'|zz'

  if len(list) > 1
    call setqflist(list)
    copen
    wincmd p
  endif
endfunction

command! -nargs=* Ag call fzf#run({
\ 'source':  printf('ag --nogroup --column --color "%s"',
\                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
\ 'sink*':    function('<sid>ag_handler'),
\ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 4.. '.
\            '--multi --bind=ctrl-a:select-all,ctrl-d:deselect-all '.
\            '--color hl:68,hl+:110',
\ 'down':    '50%'
\ })

" Complete from open tmux panes (from @junegunn)
inoremap <expr> <C-x><C-i> fzf#complete('tmuxwords.rb --all-but-current --scroll 499 --min 5')
inoremap <expr> <C-x><C-k> fzf#complete('cat /usr/share/dict/words')

" === goyo.vim/limelight.vim ===
autocmd! User GoyoEnter Limelight " Integrate limelight and goyo
autocmd! User GoyoLeave Limelight!

" === vim-jsx ===
let g:jsx_ext_required = 0 " Allow JSX in normal JS files

" === lightline.vim ===
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [
      \             ['mode', 'paste'],
      \             ['fugitive', 'readonly', 'myfilename', 'modified']
      \           ]
      \ },
      \ 'component': {
      \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}',
      \ },
      \ 'component_function': {
      \   'myfilename': 'LightLineFilename',
      \ },
      \ 'component_visible_condition': {
      \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
      \ }
      \ }

function! LightLineFilename()
  let git_root = fnamemodify(fugitive#extract_git_dir(expand("%:p")), ":h")

  if expand("%:t") == ""
    return "[No Name]"
  elseif git_root != "" && git_root != "."
    return substitute(expand("%:p"), git_root . "/", "", "")
  else
    return expand("%:p")
  endif
endfunction

" === vim-markdown ===
let g:markdown_fenced_languages = ['html', 'ruby', 'bash=sh', 'javascript', 'css', 'sql', 'vim']

" === vim-marked ===
if s:darwin
  let g:marked_app = 'Markoff' " Use thoughtbot's Markoff for markdown previews on MacOS
endif

" === omnicompletion ===
filetype plugin on
set omnifunc=syntaxcomplete#Complete
inoremap <c-c> <c-x><c-o>
set complete=.,b,u,w,t,] " Pull from keywords in the current file and from the current tags file
set complete+=k~/.vim/dictionaries/array_methods.txt
set complete+=k~/.vim/dictionaries/float_methods.txt
set complete+=k~/.vim/dictionaries/hash_methods.txt
set complete+=k~/.vim/dictionaries/integer_methods.txt
set complete+=k~/.vim/dictionaries/string_methods.txt
set complete+=k~/.vim/dictionaries/rails_controller_completions.txt
set complete+=k~/.vim/dictionaries/rails_mailer_completions.txt
set complete+=k~/.vim/dictionaries/rails_migration_completions.txt
set complete+=k~/.vim/dictionaries/rails_model_completions.txt
set complete+=k~/.vim/dictionaries/rails_spec_completions.txt
set complete+=k~/.vim/dictionaries/ruby_template_completions.txt
set complete+=k~/.vim/dictionaries/capybara_matchers.txt
set complete+=k~/.vim/dictionaries/webdriver_io.txt
set completeopt=menu,preview " Shows menu and any addition tips

" === vim-one ===
colorscheme one

" === vim-railscasts-theme ===
" colorscheme railscasts

" === rainbow_parentheses.vim ===
augroup rainbow
  autocmd BufRead,BufNewFile * RainbowParentheses
augroup END

" === vim-signify ===
let g:signify_vcs_list = [ 'git' ]

" === vim-sneak ===
let g:sneak#s_next = 1
let g:sneak#label = 1

" === vim-test ===
let test#strategy = "dispatch"
" this rspec command is SpreeCommerce specific. Don't copy unless you need to
let test#ruby#rspec#executable = 'SPEC_ALL=true bundle exec rspec'
if has("nvim")
  " open vim-test in neovim terminal if using neovim
  let test#strategy = "neovim"
endif

" === vim-tmux-navigator ===
" To use c-h in neovim on OS X
" (https://github.com/neovim/neovim/issues/2048#issuecomment-78045837):
" infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > $TERM.ti
" tic $TERM.ti
nnoremap <silent> <c-h> :TmuxNavigateLeft<CR>
nnoremap <silent> <c-j> :TmuxNavigateDown<CR>
nnoremap <silent> <c-k> :TmuxNavigateUp<CR>
nnoremap <silent> <c-l> :TmuxNavigateRight<CR>
" nnoremap <silent> <c-\> :TmuxNavigatePrevious<CR> TODO: fix this
" do nay let the plugin set the mappings
let g:tmux_navigator_no_mappings = 1
" Save on switch
let g:tmux_navigator_save_on_switch = 1

"  ____ ____ ____ ____
" ||m |||a |||p |||s ||
" ||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|

" === automatically rebalance windows on vim resize ===
autocmd VimResized * :wincmd =

" === zoom a vim pane, <C-w>= to re-balance ===
nnoremap <Leader>- :wincmd _<CR>:wincmd \|<CR>
nnoremap <Leader>= :wincmd =<CR>

" === Get dot command repeatability in visual mode (from @geoffharcourt) ===
xnoremap . :normal.<CR>

" === Toggle spell checking on and off ===
nnoremap <silent> <Leader>, :set spell!<CR>

" === Comment/un-comment like Sublime (from @geoffharcourt) ===
nnoremap <C-\> :TComment<CR>
vnoremap <C-\> :TComment<CR>

" === Use C-Space to Esc out of any mode (from @christoomey) ===
nnoremap <C-Space> <Esc>:noh<CR>
vnoremap <C-Space> <Esc>gV
onoremap <C-Space> <Esc>
cnoremap <C-Space> <C-c>
inoremap <C-Space> <Esc>`^
if s:darwin
  " oTerminal sees <C-@> as <C-space> WTF, but ok
  nnoremap <C-@> <Esc>:noh<CR>
  vnoremap <C-@> <Esc>gV
  onoremap <C-@> <Esc>
  cnoremap <C-@> <C-c>
  inoremap <C-@> <Esc>`^
endif

" === make tab completion travel in a reasonable direction (from @geoffharcourt) ===
inoremap <S-Tab> <C-P>
function! s:check_back_space()
  let col = col('.') - 1
  return !col || getline('.')[col - 1] !~ '\k'
endfunction

function! InsertTabWrapper()
  if s:check_back_space()
    return "\<Tab>"
  else
    return "\<C-n>"
  endif
endfunction

" === Emacs-like beginning and end of line. Experimental, breaks things you might be
" using. ===
nnoremap 0 ^
nnoremap <C-e> $
imap <C-a> <C-o>^
imap <C-e> <C-o>$

" === Require pry (from @christoomey) ===
nnoremap <Leader>b orequire 'pry'; binding.pry<esc>^

" === Let's stop typing ':Bundle' ===
nnoremap <Leader>bu :Bundle<CR>

" === map <ctrl>c to quit ===
nnoremap <C-c> :q<CR>

" === Copy the entire buffer into the system register (from @R00k) ===
nnoremap <Leader>co mmggVG"*y`m

" === Run them migrations ===
nnoremap <Leader>dm :! rails db:migrate<CR>

" === Convert Ruby 1.8 to 1.9 Hash Syntax ===
nnoremap <Leader>h :%s/:\([^ ]*\)\(\s*\)=>/\1:/g<CR>

" === Open .html pages from vim in browser ===
nnoremap <Leader>ht :!open '%'<CR>

" === Indent the whole file ===
nnoremap <Leader>i mmgg=G`m

" === Move up and down by visible lines if current line is wrapped ===
nnoremap j gj
nnoremap k gk

" === Mappings to move lines. Symbols represent 'alt' because macs are insane ===
" 'j' = '∆' and 'k' = '˚'
" http://stackoverflow.com/questions/7501092/can-i-map-alt-key-in-vim
if s:darwin
  nnoremap ˚ :m .-2<CR>==
  nnoremap ∆ :m .+1<CR>==
  inoremap ˚ <Esc>:m .-2<CR>==gi
  inoremap ∆ <Esc>:m .+1<CR>==gi
  vnoremap ˚ :m '>-2<CR>gv=gv
  vnoremap ∆ :m '<+1<CR>gv=gv
endif
" For Linux
nnoremap <A-k> :m .-2<CR>==
nnoremap <A-j> :m .+1<CR>==
inoremap <A-k> <Esc>:m .-2<CR>==gi
inoremap <A-j> <Esc>:m .+1<CR>==gi
vnoremap <A-k> :m '>-2<CR>gv=gv
vnoremap <A-j> :m '<+1<CR>gv=gv

" === Make esc more user friendly / ii is for Colemak ===
inoremap jk <esc>:w<CR>
inoremap ii <esc>:w<CR>
xnoremap jk <Esc>
xnoremap ii <esc>

" === Toggle relative line number for yanking, i.e. :6y ===
nnoremap <Leader>ln :set relativenumber!<CR>

" === make n N nicer ===
function! s:nice_next(cmd)
  let view = winsaveview()
  execute "normal! " . a:cmd
  if view.topline != winsaveview().topline
    normal! zz
  endif
endfunction
nnoremap <silent> n :call <SID>nice_next('n')<CR>
nnoremap <silent> N :call <SID>nice_next('N')<CR>

" === sed it up ===
nnoremap <Leader>n :%s/\(<c-r>=expand("<cword>")<CR>\)/

" === open and close location list ===
nnoremap <Leader>o :lopen<CR>
nnoremap <Leader>oo :lclose<CR>

" === Set paste so paste works properly ===
nnoremap <Leader>p "*p

" === qq to record, Q to replay (recursive map due to peekaboo) ===
nmap Q @q

" === Source (reload) your vimrc ===
nnoremap <Leader>re :source $MYVIMRC<CR>

" === Make it easier to run ruby files inside vim ===
nnoremap <Leader>ru :!ruby -w %<CR>

" === Edit the db/schema.rb Rails file in a split ===
nnoremap <Leader>sc :split db/schema.rb<CR>

" === Show syntax highlighting groups for word under cursor, useful for editing
" colorschemes (from @drewneil) ===
nnoremap <Leader>syn :call <SID>SynStack()<CR>
function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

" === map visual-block to v ===
nnoremap v <c-v>e

" === Pre-populate a split command with the current directory ===
nnoremap <Leader>v :new <C-r>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <Leader>vn :vnew <C-r>=escape(expand("%:p:h"), ' ') . '/'<CR>

" === Open vimrc in new tab ===
nnoremap <Leader>vi :tabe ~/dotfiles-local/vimrc.local<CR>
nnoremap <Leader>vb :tabe ~/dotfiles-local/vimrc.bundles.local<CR>

" === Code notes ===
nnoremap <Leader>ww :Files ~/dotfiles-local/vim_notes/<CR>
nnoremap <Leader>wt :Sexplore ~/dotfiles-local/vim_notes/<CR>

" === Run vimscript functions ===
nnoremap <Leader>x :exec getline(".")<CR>

" === Yank to end of line instead of whole line (from @geoffharcourt) ===
nnoremap Y y$

" === Make yank behave like yank should ===
vnoremap <expr>y "my\"" . v:register . "y`y"

"  ____ ____ ____ ____ ____ ____
" ||n |||e |||o |||v |||i |||m ||
" ||__|||__|||__|||__|||__|||__||
" |/__\|/__\|/__\|/__\|/__\|/__\|

if has("nvim")
  set termguicolors " nvim gui colors

  " === the new cursor in 0.2.0 is awesome but might not be default for long so
  " leaving this enabled even if it disappears ===
  let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

  " === Neovim terminal mappings for easy navigation ===
  au BufEnter * if &buftype == 'terminal' | :startinsert | endif
  tnoremap <C-h> <C-\><C-n><C-w>h
  tnoremap <C-j> <C-\><C-n><C-w>j
  tnoremap <C-k> <C-\><C-n><C-w>k
  tnoremap <C-l> <C-\><C-n><C-w>l
  tnoremap <C-d> <C-\><C-n>:bd!<CR>

  " === NeoVim term colors ===
  let g:terminal_color_0  = '#282c34' " black
  let g:terminal_color_1  = '#e26b73' " red
  let g:terminal_color_2  = '#96c475' " green
  let g:terminal_color_3  = '#d29b61' " yellow
  let g:terminal_color_4  = '#5daef2' " blue
  let g:terminal_color_5  = '#c775e0' " magenta
  let g:terminal_color_6  = '#51b6c3' " cyan
  let g:terminal_color_7  = '#abb2bf' " white
  let g:terminal_color_8  = '#282c34' " brblack
  let g:terminal_color_9  = '#e26b73' " brred
  let g:terminal_color_10 = '#96c475' " brgreen
  let g:terminal_color_11 = '#d29b61' " bryellow
  let g:terminal_color_12 = '#5daef2' " brblue
  let g:terminal_color_13 = '#c775e0' " brmagenta
  let g:terminal_color_14 = '#51b6c3' " brcyan
  let g:terminal_color_15 = '#abb2bf' " brwhite
endif
